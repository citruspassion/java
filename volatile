https://www.cnblogs.com/dolphin0520/p/3920373.html 参考链接
这个关键字与Java内存息息相关 
简述一下内存是什么。i=i+1比如这一句我们肯定知道这就是加1.从主存种读取i的值，然后将他复制到高速缓存种，然后CPU下达指令进行运算，然后将结果再写入到高速缓存去
，最后刷新到主存
比如我们有两个线程同时执行这个操作，那么最好的情况就是出现2，但是线程是将将i复制到各自的高速缓存区种，加入线程1已经将结果复制到高速缓存区了，并写入了内存，而这时线程2比他慢点，他才结果复制到
高速缓存区，于是主存被刷新时结果就是1，而不是2了，这样就造成了数据的丢失
那么就提出了用锁，来解决这个结果，可是一旦锁住，其他人就没法访问内存区了，效率就会极大下降

所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议

当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态
，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
==================================================================
并发编程有三个概念
1.原子性
2.可见性
3.有序性
在事务中我们就提到过原子性，就是要么成功，要么都失败，在这里依然是这个意思，要么全都执行，要么就都不执行
如果我们给一个32位的变量进行赋值，那么如果没有原子性，会出现什么情况，通常32位分为高16位，低16位，如果我们给高16位赋值，低16位赋值到一半去干别的了，那么
有一个线程恰好读取了这个变量，那么最后的结果就是错的

2.可见性，这个比较好理解
//线程1执行的代码
i=10
//线程2执行的代码
j=i
最后j的结果会是10，这就是可见性，j只有在知道i的值的时候才能答案是10，
3.有序性，就是执行顺序要按我们写代码的顺序来
但是jvm不一定完整的按照我们的代码顺序来，这涉及到一个重排序的问题
处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
但是这在单线程里可能没什么，没有什么顾虑
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
但在多线程中，可能重排序先走的语句2，后走语句1，那就直接导致一件事，线程2报废，他没按我们想的那样去睡觉

==========================================================================================================
此处完全借鉴，还是顶部那个链接，侵删
请分析以下哪些操作是原子性操作：

x = 10;         //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4
语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。

　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。

　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。

 　　所以上面4个语句只有语句1的操作具备原子性。

====也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。======

Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。
由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。
当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而synchronized lock也可以，保证可见性
=======================================================================================================================================
volatile其实上保证了两点
1.一个线程修改了变量，其他线程马上能知道他改成啥了   一旦被修饰，那么就会强制写入主存
2。禁止了重排序
、重点来，他不一定能保证原子性，比如自增，就和上面的例子一样，解释了只有赋值，读取才算原子性，那么自增就不算
volatile不能保证所有操作都是原子性的，所以不一定保证原子性
但是我们可以通过使用synchronized



=============================
使用volatile关键字的场景
1.旗帜变量，当我们需要使用来oolean flag来进行一些我们想要的操作
volatile boolean flag = false;
 
while(!flag){
    doSomething();
}
 
public void setFlag() {
    flag = true;
}
2.双重认证
class Singleton{
    private volatile static Singleton instance = null;
     
    private Singleton() {
         
    }
     
    public static Singleton getInstance() {
        if(instance==null) {
            synchronized (Singleton.class) {
                if(instance==null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
