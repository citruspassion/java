内存区域是指 Jvm 运行时将数据分区域存储，强调对内存空间的划分。
内存模型（Java Memory Model，简称 JMM ）是定义了线程和主内存之间的抽象关系

jdk8以前的内存区域

方法区 虚拟机栈 堆 程序计数器  本地方法栈
jkd8以后的内存区域   虚拟机栈 堆 程序计数器  metaspace   codecache jit编译产物


程序计数器
 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令
 为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存
 线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
 执行的是 Native 方法，这个计数器值则为空（Undefined）
 
 
Java虚拟机栈
与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。
虚拟机栈描述的是 Java 方法执行的内存模型       

每个方法在执行的同时都会创建一个栈帧 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

1局部变量表中存放了方法的参数和方法内部定义的局部变量。boolean、byte、char、short、int、float、reference、returnAddress。
2操作栈        初始状态为空的桶式结构栈。在方法执行过程中， 会有各种指令往栈中写入和提取信息


i++ 和 ++i 的区别：

i++：从局部变量表取出 i 并压入操作栈，然后对局部变量表中的 i 自增 1，将操作栈栈顶值取出使用，最后，使用栈顶值更新局部变量表，如此线程从操作栈读到的是自增之前的值。
++i：先对局部变量表的 i 自增 1，然后取出并压入操作栈，再将操作栈栈顶值取出使用，最后，使用栈顶值更新局部变量表，线程从操作栈读到的是自增之后的值。

i++ 不是原子操作，即使使用 volatile 修饰也不是线程安全，就是因为，可能 i 被从局部变量表（内存）取出，
压入操作栈（寄存器），操作栈中自增，使用栈顶值更新局部变量表（寄存器更新写入内存），其中分为 3 步，volatile 保证可见性，
保证每次从局部变量表读取的都是最新的值，但可能这 3 步可能被另一个线程的 3 步打断，产生数据互相覆盖问题，从而导致 i 的值比预期的小。



3动态链接 每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。
4方法返回地址   方法执行时有两种退出情况：

正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；
异常退出。




本地方法栈
本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的
它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
Sun HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一。

