锁是离不开线程的，那么线程和进程是什么关系呢，一个程序至少要有一个线程，一个进程也是至少需要一个线程的
线程是执行的最小单位，进程是资源调度单位
每个线程可以继承thread,或者runnable callable里的start方法开启线程
除此之外还有stop,join,sleep,run的方法，而wait,notify不是thread里的方法，来自于object。分别为线程挂起，线程唤醒
（多说一句sleep，wait区别，抱锁睡觉，放锁等待）
那么线程的状态也是必须得多嘴一下的，通常为5步，
1.新建状态    新建线程对象，没有开始start
2.就绪状态    等待start,或者刚被唤醒或者挂起的线程也回在就绪状态
3.运行状态    执行run
4.阻塞状态     暂停
5.死亡状态    结束
其中就绪，运行，阻塞是三角恋
线程运行就跟交通一样，会有堵车的情况
这种情况就是死锁
死锁有4种情况
1.互斥，一个资源每次只能被一个使用   和一夫一妻一样，一个老婆一个老公
2.请求与保持，一个进程因请求资源被阻塞，会对持有的资源抱着不放  就是没有把握不能离婚
3.不剥夺  进程已经获得的资源，在未使用完，不能强行剥夺   别人的老婆不能动
4.循环等待 若干进程之间形成头尾相接的循环等待    两情人互相等对方离婚

java的每个对象都可以作为锁，而我们上锁的不是代码，锁的是对象，
按功能分，隐式锁，显式锁
隐式锁就是常用的synchronized
显式锁有两个接口，lock,readwritelock
主要实现类为reentrantlock reentrantreadwritelock
锁分为四个级别
从轻到重，无锁，偏向锁，轻量级锁，重量级锁
刚开始都是无锁的，得往上升级，进程争夺越激烈锁级别就得越高，并且锁只能升级不能降级
按级别如此划分，按类型呢
1.可重入锁， 顾名思义，执行对象中所有同步方法中不用再次获得锁      不用重复还钥匙
2.可中断锁，在等待获取锁的时候可以中断                            下订单想退货
3.公平锁，按等待时间来决定先后获取锁的顺序，等待时间长的先获得      以老为尊
4.读写锁，读写分开，读的时候多线程一起读，写的时候同步写

那么接下来该说标题两个的区别了
这时我们多线程解决矛盾的两好方法。那么他俩啥区别呢
synchronized                              lock
是一个关键字   作用于jvm                             是一个接口
发生异常就自定释放锁                        异常不会自动释放，必须手动unlock，所以有可能会死锁，所以必须try/catch包裹一下并在finally里unlock
响应中断：想中断只能等待锁的释放                            可以用interupt中断
判断锁状态：他不能直到有没有获取锁                           可以通过trylock知道有没有获得锁
   /                                             提高多线程读的操作，readwritelock，读写分离锁
   竞争激烈：性能稍弱                               性能稍强
   使用wait,notify,notifyall调度                        使用condition调度
类型：可重入，不可中断，非公平                           可重入，可中断，可公平
少量同步·                                                   大量同步
本质悲观锁                                             本质乐观锁

synchronized可以作用在对象，方法，块中
1.6之前synchron是一个重量级锁，通过内部的监视器锁monitor实现，(记录锁的持有线程，等待队列信息，每个对象都有一个锁，和一个等待队列)
后来发现锁定状态只持续很短时间，为了这么一小会就给他挂起恢复，没啥必要，所以引入了自旋，在等待线程执行一定次数的循环后，在循环中等待锁
这就是自选锁，1.6以后就引入了自适应的自旋锁，不需要通过次数来限制，有上一次同锁的自选时间以及锁的拥有者的状态决定

锁清除
如果虚拟机运行发现有一段代码不能共享数据，那么就会消除

锁粗化
虚拟机检测到有零星操作对同一个对象加锁，就会把锁扩展到整个操作序列外部，比如stringbuffer append
synchronized 是独占锁 自动进行灵活使用reentrantlock
