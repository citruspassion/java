锁是离不开线程的，那么线程和进程是什么关系呢，一个程序至少要有一个线程，一个进程也是至少需要一个线程的
线程是执行的最小单位，进程是资源调度单位
每个线程可以继承thread,或者runnable callable里的start方法开启线程
除此之外还有stop,join,sleep,run的方法，而wait,notify不是thread里的方法，来自于object。分别为线程挂起，线程唤醒
（多说一句sleep，wait区别，抱锁睡觉，放锁等待）
那么线程的状态也是必须得多嘴一下的，通常为5步，
1.新建状态    新建线程对象，没有开始start
2.就绪状态    等待start,或者刚被唤醒或者挂起的线程也回在就绪状态
3.运行状态    执行run
4.阻塞状态     暂停
5.死亡状态    结束
其中就绪，运行，阻塞是三角恋
就绪 运行互相爱
线程运行就跟交通一样，会有堵车的情况
这种情况就是死锁
死锁有4种情况
1.互斥，一个资源每次只能被一个使用   和一夫一妻一样，一个老婆一个老公
2.请求与保持，一个进程因请求资源被阻塞，会对持有的资源抱着不放  就是没有把握不能离婚
3.不剥夺  进程已经获得的资源，在未使用完，不能强行剥夺   别人的老婆不能动
4.循环等待 若干进程之间形成头尾相接的循环等待    两情人互相等对方离婚

java的每个对象都可以作为锁，而我们上锁的不是代码，锁的是对象，
按功能分，隐式锁，显式锁
隐式锁就是常用的synchronized
显式锁有两个接口，lock,readwritelock
主要实现类为reentrantlock reentrantreadwritelock
锁分为四个级别
从轻到重，无锁，偏向锁，轻量级锁，重量级锁
刚开始都是无锁的，得往上升级，进程争夺越激烈锁级别就得越高，并且锁只能升级不能降级
按级别如此划分，按类型呢
1.可重入锁， 顾名思义，执行对象中所有同步方法中不用再次获得锁      不用重复还钥匙
2.可中断锁，在等待获取锁的时候可以中断                            下订单想退货
3.公平锁，按等待时间来决定先后获取锁的顺序，等待时间长的先获得      以老为尊
4.读写锁，读写分开，读的时候多线程一起读，写的时候同步写

那么接下来该说标题两个的区别了
这时我们多线程解决矛盾的两好方法。那么他俩啥区别呢
synchronized                              lock
是一个关键字   作用于jvm                             是一个接口
发生异常就自定释放锁                        异常不会自动释放，必须手动unlock，所以有可能会死锁，所以必须try/catch包裹一下并在finally里unlock
响应中断：想中断只能等待锁的释放                            可以用interupt中断
判断锁状态：他不能直到有没有获取锁                           可以通过trylock知道有没有获得锁
   /                                             提高多线程读的操作，readwritelock，读写分离锁
   竞争激烈：性能稍弱                               性能稍强
   使用wait,notify,notifyall调度                        使用condition调度
类型：可重入，不可中断，非公平                           可重入，可中断，可公平
少量同步·                                                   大量同步
本质悲观锁                                             本质乐观锁

synchronized可以作用在对象，方法，块中
1.6之前synchron是一个重量级锁， Java对象头、monitor：Java对象头和monitor是实现synchronized的基础，( 监视器就是记录锁的持有线程，等待队列信息，每个对象都有一个锁，和一个等待队列)
但是随着Java SE1.6对Synchronized进行了各种优化之后，有些情况下它并不那么重了，Java SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程

那么我们先说说这个java头
synchronized就存放在java头中，他包含了两个数据Mark Word（标记字段）、Klass Pointer（类型指针）
mark word就是标志位，在虚拟机32位64位中他是最后两位，锁状态标志位，用来标记当前对象的状态
比如00 轻量级锁   10 重量级     01未锁定或者可偏向
而类型指针进行判断的，用来知道这个对象是谁的实例


轻量级锁：
当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁
步骤：
判断状态，是否无锁，如果无锁，就会在当前线程的栈帧中建立一个锁记录，储存当前的锁状态标志位，然后jvm会尝试以cas操作将对象的Mark Word更新为指向Lock Record的指正
如果成功竞争到锁，则将标志位变成00，轻量级  如果失败，就是即便他没拿到锁，变更标志位，我们也要进行判断当前标志位是否指向当前线程的栈帧。如果是，则说明已经持锁，
为漏网之余，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，则膨胀为重量级锁。锁标志位变成10，后面等待的线程将会进入阻塞状态； 
如果有锁，则需要判断当前标志位是否指向当前线程的栈帧，如果是，则说明已经持锁，
，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，则膨胀为重量级锁。锁标志位变成10，后面等待的线程将会进入阻塞状态
 
 什么是CAS操作？

compare and swap,CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。
是并发包里的一个核心组件，里面有state变量、加锁线程变量等核心的东西，维护了加锁状态。

偏向锁：
轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是减少了不必要的CAS操作
只需要检查是否为偏向锁、锁标识为以及ThreadID即可
1检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；

2若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；

3如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；

4通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，=====然后被阻塞在安全点的线程继续往下执行同步代码块=====重点；

5执行同步代码块。 


自旋锁
后来发现锁定状态只持续很短时间，为了这么一小会就给他挂起恢复，没啥必要，所以引入了自旋，在等待线程执行一定次数的循环后，在循环中等待锁
这就是自选锁，1.6以后就引入了自适应的自旋锁，不需要通过次数来限制，有上一次同锁的自选时间以及锁的拥有者的状态决定

锁清除
如果虚拟机运行发现有一段代码不能共享竞争数据，那么就会消除锁
　比如StringBuffer的append()方法，Vector的add()方法：
 为了减少请求变量的时间，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术。如果没有检测到逃逸现象，就会把锁消除

锁粗化
虚拟机检测到有零星操作对同一个对象加锁，就会把锁扩展到整个操作序列外部，比如stringbuffer append


下面聊聊reentrantlock
ReentrantLock、ReentrantReadWriteLock底层都是基于AQS来实现的

这个AQS对象内部有一个核心的变量叫做state，是int类型的，代表了加锁的状态，初始状态下，这个state的值是0
这个AQS内部还有一个关键变量，用来记录当前加锁的是哪个线程，初始化状态下，这个变量是null。
那么我们可以看出这其实跟synchronized是对标的
因为synchronized也有一个记录锁状态，和判断的东西
我们回到reentrantlock的话题
接着线程1跑过来调用ReentrantLock的lock()方法尝试进行加锁，这个加锁的过程，直接就是用CAS操作将state值从0变为1。
如果之前没人加过锁，那么state的值肯定是0，此时线程1就可以加锁成功。

一旦线程1加锁成功了之后，就可以设置当前加锁线程是自己
那么我们上面提到他是一个可重入锁，你可以对一个ReentrantLock对象多次执行lock()加锁和unlock()释放锁，也就是可以对一个锁加多次
其实每次线程1可重入加锁一次，会判断一下当前加锁线程就是自己，那么他自己就可以可重入多次加锁，每次加锁就是把state的值给累加1
接着，如果线程1加锁了之后，线程2跑过来加锁会怎么样呢？
线程2将0变1的操作一定会失败 线程2会将自己放入AQS中的一个等待队列
等待线程1释放锁之后，自己就可以重新尝试加锁了
那么释放锁就是  就是将AQS内的state变量的值递减1，如果state值为0，则彻底释放锁，会将“加锁线程”变量也设置为null
会从等待队列的队头唤醒线程2重新尝试加锁。
好！线程2现在就重新尝试加锁，这时还是用CAS操作将state从0变为1，此时就会成功，成功之后代表加锁成功，就会将state设置为1。

 

此外，还要把“加锁线程”设置为线程2自己，同时线程2自己就从等待队列中出队了

