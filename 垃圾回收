我们都知道堆种存放着所有的对象的实例  方法结束或者线程结束时，内存就自然跟着线程回收了
垃圾回收器在堆进行垃圾回收前，要先判断对象是否已死

1.引用计数法
让对象携带一个引用计数器，每当被引用一次就+1，引用失效就-1  任何时刻计数器为0的对象就是不能再被使用的，即对象已“死”
但是jvm没有用这个
因为它的缺点就是 不能解决循环引用的问题

2.jvm采用可达性分析

通过一个叫gc_roots的对象作为起始点，然后开始向下搜索，走过的路叫引用链
当一个对象到gc_roots没有任何引用链  则这个对象不可用 就挂了

可作为GC Roots的对象包含以下几种：

虚拟机栈(栈帧中的本地变量表)中引用的对象。
方法区中静态属性引用的对象
方法区中常量引用的对象
本地方法栈中(Native方法)引用的对象

在JDK1.2之后，Java对引用的概念做了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、
弱引用(Weak Reference)和虚引用(Phantom Reference)四种，这四种引用的强度依次递减


强引用: 强引用指的是在程序代码之中普遍存在的，类似于"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象实例。
软引用: 软引用是用来描述一些还有用但是不是必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围之中进行第二次回收。
如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。
弱引用: 弱引用也是用来描述非必需对象的。但是它的强度要弱于软引用。被弱引用关联的对象只能生存到下一次垃圾回收发生之前。
当垃圾回收器开始进行工作时，无论当前内容是否够用，都会回收掉只被弱引用关联的对象。在JDK1.2之后提供了WeakReference类来实现弱引用。
虚引用: 虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。


引用类型   被回收时间    用途              生存时间     
强引用     从来不会    对象的一般状态         jvm停止

软引用     内存不足         对象缓存           内存不足停止
  
弱引用     垃圾回收        对象缓存          gc运行后停止

虚引用     任何时候都可能   标记，哨兵      未知

————————————————
版权声明：本文为CSDN博主「LiuWang_1122」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
参考引用链接：https://blog.csdn.net/yubujian_l/article/details/80804708


但是使用这个可达性分析判断，假如有的对象并无和gc_roots无任何引用链，但是这个对象自身向下搜索却有相连，这些对象被第一次标记
并进行一次筛选，即该对象是否有必要执行finalize方法 ，当对象没有覆盖ﬁnalize()方法或者ﬁnalize()方法已经被JVM调用过 ，则判断对象已死

当对象被判断有必要执行finalize，这个对象会被放在F-Queue的队列之中
ﬁnalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，
如果对象在ﬁnalize()中成功拯救自己(只需要重新与引用链上的任何一个对象建立起关联关系即可)，
那在第二次标记时它将会被移除出"即将回收"的集合；如果对象这时候还是没有逃脱，那基本上它就是真的被回收了




请问了解Minor GC和Full GC么，这两种GC有什么不一样吗？

Minor GC又称为新生代GC : 指的是发生在新生代的垃圾收集。因为Java对象大多都具备朝生夕灭的特性，因此Minor GC(采用复制算法)非常频繁，一般回收速度也比较快。


Full GC 又称为老年代GC或者Major GC : 指发生在老年代的垃圾收集。出现了Major GC，经常会伴随至少一次的Minor GC(并非绝对，
在Parallel Scavenge收集器中就有直接进行Full GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。


堆内存结构
heap区分为Young Gen（新生代）、老年代Old Gen（老年代），其中新生代被分为Eden Space（伊甸区）、 Survivor Space(幸存者区)，依旧是我们常说的From/to区 。


Eden Space字面意思是伊甸园，对象被创建的时候首先放到这个区域

Survivor区也被称为幸存者区，在垃圾回收时，eden空间中的存活对象会被复制到未使用的Survivor空间中（假设是to区）（复制算法），
正在使用的survivor空间（假设是from）中的年轻对象也会被复制到to空间中。此时，eden空间和from空间中的剩余对象就是垃圾对象，可以被直接清空。

新生代中执行的垃圾回收被称之为Minor GC（因为是对新生代进行垃圾回收，所以又被称为Young GC），每一次Young GC后留下来的对象age加1。
当老年代被放满的之后，虚拟机会进行垃圾回收，称之为Major GC。由于Major GC除并发GC外均需对整个堆进行扫描和回收，因此又称为Full GC。



Minor GC ，Full GC 触发条件
Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）方法区空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小





————————————————
版权声明：本文为CSDN博主「Anstrue」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/beautiful_face/article/details/77722635
