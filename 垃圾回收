我们都知道堆种存放着所有的对象的实例  方法结束或者线程结束时，内存就自然跟着线程回收了
垃圾回收器在堆进行垃圾回收前，要先判断对象是否已死

1.引用计数法
让对象携带一个引用计数器，每当被引用一次就+1，引用失效就-1  任何时刻计数器为0的对象就是不能再被使用的，即对象已“死”
但是jvm没有用这个
因为它的缺点就是 不能解决循环引用的问题

2.jvm采用可达性分析

通过一个叫gc_roots的对象作为起始点，然后开始向下搜索，走过的路叫引用链
当一个对象到gc_roots没有任何引用链  则这个对象不可用 就挂了

可作为GC Roots的对象包含以下几种：

虚拟机栈(栈帧中的本地变量表)中引用的对象。
方法区中静态属性引用的对象
方法区中常量引用的对象
本地方法栈中(Native方法)引用的对象

在JDK1.2之后，Java对引用的概念做了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、
弱引用(Weak Reference)和虚引用(Phantom Reference)四种，这四种引用的强度依次递减


强引用: 强引用指的是在程序代码之中普遍存在的，类似于"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象实例。

强引用可以直接访问目标对象
强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象
强引用可能导致内存泄漏。



软引用: 软引用是用来描述一些还有用但是不是必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围之中进行第二次回收。
如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。



弱引用: 弱引用也是用来描述非必需对象的。但是它的强度要弱于软引用。被弱引用关联的对象只能生存到下一次垃圾回收发生之前。
当垃圾回收器开始进行工作时，无论当前内容是否够用，都会回收掉只被弱引用关联的对象。在JDK1.2之后提供了WeakReference类来实现弱引用。
虚引用: 虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。


引用类型   被回收时间    用途              生存时间     
强引用     从来不会    对象的一般状态         jvm停止

软引用     内存不足         对象缓存           内存不足停止
  
弱引用     垃圾回收        对象缓存          gc运行后停止

虚引用     任何时候都可能   标记，哨兵      未知

————————————————
版权声明：本文为CSDN博主「LiuWang_1122」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
参考引用链接：https://blog.csdn.net/yubujian_l/article/details/80804708


但是使用这个可达性分析判断，假如有的对象并无和gc_roots无任何引用链，但是这个对象自身向下搜索却有相连，这些对象被第一次标记
并进行一次筛选，即该对象是否有必要执行finalize方法 ，当对象没有覆盖ﬁnalize()方法或者ﬁnalize()方法已经被JVM调用过 ，则判断对象已死

当对象被判断有必要执行finalize，这个对象会被放在F-Queue的队列之中
ﬁnalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，
如果对象在ﬁnalize()中成功拯救自己(只需要重新与引用链上的任何一个对象建立起关联关系即可)，
那在第二次标记时它将会被移除出"即将回收"的集合；如果对象这时候还是没有逃脱，那基本上它就是真的被回收了


4中垃圾清理算法

1.标记清理
2.复制    新生代 串行 并行
3.标记整理   老年代  回收
3，分代整理    根据存活周期的不同将内存划分为几块
也就是分为  新生代 ，老年代


请问了解Minor GC和Full GC么，这两种GC有什么不一样吗？

Minor GC又称为新生代GC : 指的是发生在新生代的垃圾收集。因为Java对象大多都具备朝生夕灭的特性，因此Minor GC(采用复制算法)非常频繁，一般回收速度也比较快。


Full GC 又称为老年代GC或者Major GC : 指发生在老年代的垃圾收集。出现了Major GC，经常会伴随至少一次的Minor GC(并非绝对，
在Parallel Scavenge收集器中就有直接进行Full GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。


jvm的优化  也可以这样回答
堆内存结构  分为permantspace heapspace  也就是持久代和heap代
 而permantspace  存放一些静态类型数据，如Java ，class mmethod 
heap sapce区分为Young Gen（新生代）、老年代Old Gen（老年代），其中新生代被分为Eden Space（伊甸区）、 Survivor Space(幸存者区)，依旧是我们常说的From/to区 。


Eden Space字面意思是伊甸园，对象被创建的时候首先放到这个区域



Survivor区也被称为幸存者区，在垃圾回收时，eden空间中的存活对象会被复制到未使用的Survivor空间中（假设是to区）（复制算法），
正在使用的survivor空间（假设是from）中的年轻对象也会被复制到to空间中。此时，eden空间和from空间中的剩余对象就是垃圾对象，可以被直接清空。

新生代中执行的垃圾回收被称之为Minor GC（因为是对新生代进行垃圾回收，所以又被称为Young GC），每一次Young GC后留下来的对象age加1。
当老年代被放满的之后，虚拟机会进行垃圾回收，称之为Major GC。由于Major GC除并发GC外均需对整个堆进行扫描和回收，因此又称为Full GC。



Minor GC ，Full GC 触发条件
Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）方法区空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小


年老代   溢出的原因
循环上万次的字符串处理，创建千万个对象，在一代码中申请几百m 甚至几g的内存

持久代  溢出的原因
动态加载大量java类而溢出


————————————————
版权声明：本文为CSDN博主「Anstrue」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/beautiful_face/article/details/77722635





为什么崩溃前垃圾回收的时间越来越长？

A:根据内存模型和垃圾回收算法，垃圾回收分两部分：内存标记、清除（复制），标记部分只要内存大小固定时间是不变的，变的是复制部分，
因为每次垃圾回收都有一些回收不掉的内存，所以增加了复制量，导致时间延长。所以，
==============================垃圾回收的时间也可以作为判断内存泄漏的依据===============================================

为什么Full GC的次数越来越多？

A内存不断地积累，逐渐耗尽了年老代的内存， 回看full gc回收机制，就会发现 当转为老年代内存大小如果大于老年代本身内存量就会gc清除  
从而导致频繁的垃圾回收

Q:为什么年老代占用的内存越来越大？

A:因为年轻代的内存无法被回收，越来越多地被Copy到年老代

（1）针对JVM堆的设置一般，可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值
（2）年轻代和年老代将根据默认的比例（1：2）分配堆内存
如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：
（A）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 
（B）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间


（4）在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC ，默认为Serial收集

（5）线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了
一般256K就足用。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。

————————————————
版权声明：本文为CSDN博主「奔波儿灞爱上灞波儿奔」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_36866808/article/details/80391008

